/*
    Copyright (c) 2014 "(IA)2 Research Group. Universidad de MÃ¡laga"
                        http://iaia.lcc.uma.es | http://www.uma.es

    This file is part of SISOB Data Extractor.

    SISOB Data Extractor is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    SISOB Data Extractor is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with SISOB Data Extractor. If not, see <http://www.gnu.org/licenses/>.
*/

package eu.sisob.uma.restserver.managers;

import static eu.sisob.uma.restserver.managers.AuthorizationManager.feedback_flag_file;
import eu.sisob.uma.restserver.services.communications.OutputTaskStatus;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.io.FileUtils;

/**
 *
 * @author Antonio Jesus Gallardo Albarran - antonio.jesus.gallardo@gmail.com
 */
public class TaskFileManager {
    
    private static final Logger LOG = Logger.getLogger(TaskFileManager.class.getName());
    
    public static final String PROPERTY_TASK_KIND           = "kind";
    public static final String PROPERTY_TASK_STATUS         = "status";
    public static final String PROPERTY_TASK_DATE_STARTED   = "date-started";
    public static final String PROPERTY_TASK_DATE_FINISHED  = "date-finished";
    public static final String PROPERTY_TASK_DATE_CREATED   = "date-created";
    
    
    public static String getTaskFolder(String user, String taskCode){
        return Paths.get(AuthorizationManager.TASKS_USERS_PATH, 
                            user, 
                            taskCode).toString();
    }
    
    public static String getUserFolder(String user){
        return Paths.get(AuthorizationManager.TASKS_USERS_PATH, 
                            user).toString();
    }
    
    /**
     * Return the file names of the result of a task
     * @param user 
     * @param task_code
     * @return
     */
    public static List<String> getResultFiles(String user, String task_code)
    {        
        
        List<String> results = new ArrayList();
        
        String pathResult = Paths.get(getTaskFolder(user, task_code), 
                                        AuthorizationManager.results_dirname).toString();
            
        File result_file = new File(pathResult);
        if(result_file.exists())
        {   
            List<File> tasks_folders = Arrays.asList(result_file.listFiles());
            for(File file : tasks_folders)
            {
                if (!file.isDirectory()) {
                    if (!file.getName().endsWith(".flag") && 
                        !AuthorizationManager.task_data_file.equals(file.getName())) {
                        results.add(file.getName());
                    }
                }
            }                    
        }

        return results;    
    }
    
    /**
     * Return the file names of the result of a task
     * @param user 
     * @param task_code
     * @return
     */
    public static List<String> getSourceFiles(String user, String task_code)
    {        
        
        List<String> sources = new ArrayList();
            
        File code_task_folder = new File(getTaskFolder(user, task_code));
        if(code_task_folder.exists())
        {   
            List<File> source_files = Arrays.asList(code_task_folder.listFiles());
            for(File file : source_files)
            {
                if (!file.isDirectory()) {
                    if (!file.getName().endsWith(".flag") && 
                        !AuthorizationManager.task_data_file.equals(file.getName())) {
                        sources.add(file.getName());
                    }
                }
            }                    
        }

        return sources;    
    }    
    
    /**
     * Return the file names generated by verbose mode
     * @param user 
     * @param task_code
     * @return
     */
    public static List<String> getVerboseFiles(String user, String task_code)
    {        
        
        List<String> results = new ArrayList();
        
        String pathVerbose = Paths.get(getTaskFolder(user, task_code), 
                                        AuthorizationManager.verbose_dirname).toString();
            
        File result_file = new File(pathVerbose);
        if(result_file.exists())
        {   
            List<File> tasks_folders = Arrays.asList(result_file.listFiles());
            for(File file : tasks_folders)
            {
                if (!file.isDirectory()) {
                    if (!file.getName().endsWith(".flag") && 
                        !AuthorizationManager.task_data_file.equals(file.getName())) {
                        results.add(file.getName());
                    }
                }
            }                    
        }

        return results;    
    }
    
    /**
     * Return the file names of the result of a task
     * @param user 
     * @param task_code
     * @param error_msg 
     * @return
     */
    public static boolean notifyResultError(String user, String task_code, String error_msg)
    {  
        boolean success = false;
        
        String resultFolder = Paths.get(TaskFileManager.getTaskFolder(user, task_code), 
                                AuthorizationManager.results_dirname).toString();
               
        try{
            if(new File(resultFolder).exists()){
                File error_file = new File(resultFolder + File.separator + AuthorizationManager.error_flag_file);
                FileUtils.write(error_file, error_msg + "\r\n", "UTF-8", true);                
                success = true;
            }
            else{
                LOG.log(Level.INFO, "Results folder to notify error does not exist. ({0})", resultFolder);
            }
        }
        catch (Exception ex){
            LOG.log(Level.SEVERE, "Error writing result errors (" + resultFolder + ")", ex);
        }
        
        return success;
    }
    
    /**
     * Write content in the feedback file of the task (feedback file is a plain 
     * text that may contain some text or some url to Google Docs, etc
     * 
     * @param user
     * @param task_code
     * @param feedback_content
     * @return
     */
    public static boolean updateFeedbackFile(String user, String task_code, String feedback_content)
    {
        boolean success = false;
        String file_task_folder = AuthorizationManager.TASKS_USERS_PATH + 
                                                  File.separator + user + 
                                                  File.separator + task_code + 
                                                  File.separator + AuthorizationManager.results_dirname + 
                                                  File.separator + feedback_flag_file;   
        try {
            FileUtils.write(new File(file_task_folder), feedback_content);
            success = true;
        } catch (IOException ex) {
            LOG.log(Level.SEVERE, "Error writing (" + file_task_folder + ")", ex);
        }
        
        return success;
    } 
    
    /**
     * Return the file according to the parameters (file_name of type of task_code of user)
     * @param user 
     * @param task_code
     * @param type 
     * @param file_name 
     * @return
     */
    public static File getFile(String user, String task_code, String file_name, String type)
    {
        String file_task_folder = TaskFileManager.getTaskFolder(user, task_code) + 
                                    (!type.equals("") ? File.separator + type : "") + 
                                    File.separator + file_name;
        
        File file = new File(file_task_folder);
        return file;
    }
    
    public static void createFileTaskData(String pathTaskFolder){
        
        String pathTaskData = pathTaskFolder + File.separator + AuthorizationManager.task_data_file;
        
        try {
            
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd - HH:mm:ss");
            
            Properties p = new Properties();
            p.setProperty(PROPERTY_TASK_KIND, "none");
            p.setProperty(PROPERTY_TASK_STATUS, OutputTaskStatus.TASK_STATUS_TO_EXECUTE);
            p.setProperty(PROPERTY_TASK_DATE_STARTED, "");
            p.setProperty(PROPERTY_TASK_DATE_FINISHED, "");
            p.setProperty(PROPERTY_TASK_DATE_CREATED, sdf.format(new Date()));

            OutputStream outputStream =  new FileOutputStream(pathTaskData);
            p.store(outputStream, null);
        } 
        catch (Exception e) {
            LOG.log(Level.SEVERE, "Error creating file: " + pathTaskData, e);
        }
    }
    
    public static Properties getFileTaskData(String pathTaskFolder){
        
        Properties p = null;
        try {    
            String pathTaskData = pathTaskFolder + File.separator + AuthorizationManager.task_data_file;

            p = new Properties();
            p.load(new FileReader(pathTaskData));
        } 
        catch (Exception e) {
            LOG.log(Level.SEVERE, "Error", e);
        } 
        
        return p;
    }
    
    public static void registerTaskLaunched(String pathTaskFolder, String taskKind){
        
        String pathTaskData = pathTaskFolder + File.separator + AuthorizationManager.task_data_file;

        try {
            
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd - HH:mm:ss");

            Properties p = new Properties();
            p.load(new FileReader(pathTaskData));

            p.setProperty(PROPERTY_TASK_KIND, taskKind);
            p.setProperty(PROPERTY_TASK_STATUS, OutputTaskStatus.TASK_STATUS_EXECUTING);
            p.setProperty(PROPERTY_TASK_DATE_STARTED, sdf.format(new Date()));
            p.setProperty(PROPERTY_TASK_DATE_FINISHED, "");

            OutputStream outputStream =  new FileOutputStream(pathTaskData);
            p.store(outputStream, null);
        } 
        catch (Exception e) {
            LOG.log(Level.SEVERE, "Error saving " + pathTaskData, e);
        }
    }
    
    public static void registerTaskFinished(String pathTaskFolder){
    
        String pathTaskData = pathTaskFolder + File.separator + AuthorizationManager.task_data_file;

        try {
            
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd - HH:mm:ss");
            
            Properties p = new Properties();
            p.load(new FileReader(pathTaskData));

            p.setProperty(PROPERTY_TASK_STATUS, OutputTaskStatus.TASK_STATUS_EXECUTED);
            p.setProperty(PROPERTY_TASK_DATE_FINISHED, sdf.format(new Date()));

            OutputStream outputStream =  new FileOutputStream(pathTaskData);
            p.store(outputStream, null);

        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Error register task finished" + pathTaskData, e);
        }
    }
}
